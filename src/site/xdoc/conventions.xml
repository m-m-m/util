<?xml version="1.0"?>
<!-- $Id$ -->
<document>
  <properties>
    <title>Project Conventions</title>
    <author email="hohwille@users.sourceforge.net">J&#246;rg Hohwiller</author>
  </properties>

  <body>
    <h2>Conventions</h2>
    <macro name="toc" fromDepth="0"/>
    <section name="General">
      <p>This project aims to produce high quality software. Therefore it is very
      important that the code is well designed, documented and tested.
      No sub-project should be released (as official version) if it has NOT
      been tested intensively (though it can obviously still have bugs).</p>
    </section>
    <section name="Maven">
      <p>The project is using <a href="http://maven.apache.org">maven</a>
      as build- and management-tool. Therefore the maven conventions apply 
      to this project. If you are NOT familiar with maven please read the 
      following guides:
      <ul>
        <li><a href="http://maven.apache.org/guides/getting-started/index.html">getting started</a></li>
        <li><a href="http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html">project layout</a></li>
      </ul>
      </p>
    </section>
    <section name="Code-Style">
      <p>The code produced by this project follows a common code-style.
      To check these rules, configurations for checkstyle and eclipse are 
      provided (see <a href="setup-devel.html">Setup</a>). Further
      there are additional rules to follow:
      <ul>
        <li>Names for classes and interfaces are english words that describe the type briefly.
        They are in the typical caml case (e.g. AbstractWidget). Shortcuts and acronyms are
        NOT capitalized as part of names (e.g. <code>XmlUtil</code> and NOT <strike><code>XMLUtil</code></strike>).</li>
        <li>There are no artificial conventions for names of interfaces (like 
        <code>I</code> as prefix or <code>IF</code> as suffix). The interfaces should have the nice
        names while implementations may be named artificial (<code>*Impl</code>).</li>
        <li>The code should be well documented using javadoc. It does NOT help
        just to satisfy checkstyle with some generated javadoc nonsense. Please help
        to maintain the javadoc of the code and make it precise. Make intensive use
        of the <code>{@link FooClass}</code> constructs to specify what you are talking 
        about.
        </li>
      </ul>
      </p>
    </section>
    <section name="Packages">
      <p>The projects package namespace is <code>net.sf.mmm</code>.
      All packages should be sub-packages of this namespace.
      Each logical unit of code declares a specific package 
      (say <code>net.sf.mmm.foo</code>) and is devided into the 
      following subpackages:
      <ul>
        <li><code>api</code><br/>
        contains the API and consists of interfaces and exception classes. 
        It may also contain simple container classes (e.g. event-classes or 
        maybe java-beans).
        Once released, this API should be stable. It may be extended but
        existing types and methods should NOT be changed or removed.<br/>
        The <code>api</code> code must NOT import classes from 
        <code>base</code> or <code>impl</code> packages.
        </li>
        <li><code>base</code><br/>
        contains the basic implementation of the API. It is typically
        the common bridge between the API and exchangeable implementations.
        Therefore it contains abstract classes that implement parts of the
        API that are NOT intended to be realized in a different way.
        If someone outside this project wants to write a custom implementation,
        he is supposed to extend these classes rather than directly implementing 
        the API interfaces. If in some specific circumstance the API has to be 
        extended, compatibility can be gained by covering this in the base 
        implementation.<br/>
        Additionally <code>base</code> packages may contain non-abstract classes
        or simple implementations that can be instantiated by end-users directly.
        However they should be used via the API afterwards and such classes are 
        potentially less stable than the API.<br/>
        The <code>base</code> code must NOT import classes from <code>impl</code>
        packages.
        </li>
        <li><code>impl</code><br/>
        contains the implementation(s) of the API. It should NOT be used by the 
        end-user (directly in the code). It may change internaly in subsequent
        releases.
        </li>
        <li>-<br/>
        The package itself (example was <code>net.sf.mmm.foo</code>) may also 
        contain classes. This can be an <code><em>NlsBundle</em></code>
        that contains messages that can be localized. Such class should only
        be used by code below this package.        
        </li>
      </ul>
      Each of these sub-packages may be devided into further sub-sub-packages
      (say <code>net.sf.mmm.foo.api.bar</code>) if desireable according to 
      size and complexity. The implementation (<code>net.sf.mmm.foo.impl</code>)
      can be bundled in a seperate module. In such case the <code>api</code>
      and <code>base</code> is bundled in an api module (<code>mmm-foo-api</code>)
      while the <code>impl</code> is in a separate module (<code>mmm-foo-impl</code>).
      Within <code>mmm-util</code> the <code>impl</code> will NOT be separated
      while it should be separated in other modules. If there are multiple 
      implementations for different aspects that each consist of various classes,
      they should be separated as well. This applies for java-packages
      (<code>net.sf.mmm.foo.impl.aspect1</code>) as well as for modules 
      (<code>mmm-foo-impl-aspect1</code>).<br/>
      Users should only use the API what can easily be checked 
      via the import statements (should contain <code>api</code>, should NOT 
      contain <code>base</code> and especially NOT <code>impl</code>). This NOT 
      only applies to external users but also to other code of this project, 
      though NOT always possible. A container framework is (to be) used for 
      creating instances of API interfaces. Testcases or very simple applications
      may directly create and setup implementations (from an <code>impl</code>)
      package if using such framework would be overdosed.<br/>
      The following table illustrates which packages (first column) may reference
      (import) which other packages (top-row). With reference we are NOT talking
      about javadoc <code>@link</code> tags.
      <table>
      <tr>
        <th align="right">reference -&gt;</th>
        <th>foo</th>
        <th>foo.api</th>
        <th>foo.base</th>
        <th>foo.impl</th>
        <th>bar.api</th>
        <th>bar.base</th>
        <th>bar.impl</th>
      </tr>
      <tr>
        <th>foo</th>
        <td>X</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>X</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr>
        <th>foo.api</th>
        <td>X</td>
        <td>X</td>
        <td>-</td>
        <td>-</td>
        <td>X</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr>
        <th>foo.base</th>
        <td>X</td>
        <td>X</td>
        <td>X</td>
        <td>-</td>
        <td>X</td>
        <td>(X)</td>
        <td>-</td>
      </tr>
      <tr>
        <th>foo.impl</th>
        <td>X</td>
        <td>X</td>
        <td>X</td>
        <td>X</td>
        <td>X</td>
        <td>(X)</td>
        <td>-</td>
      </tr>
      </table>
      </p>
    </section>
    <section name="Components">
      This project follows the principle of component-oriented-design. 
      So what is a component? First of all a common definition:<br/><br/>
      "A <em>component</em> is a reusable piece of software that offers its 
      functionallity through a well-defined and self-contained API. Its 
      implementation is therefore exchangeable and can be composed using
      other components."<br/><br/>
      So far so good. While such definition is easily agreed by most developers
      it is still very unprecise. However if we are talking about the term
      component it is important that we mean the same thing. Therefore I want
      to make it a bit more precise. The only successful chance to do so is by
      defining new terms rather than redefining a term that is so widely used and
      missunderstood than the term component.
      <subsection name="Micro-Component">
        A <em>micro-component</em> is a piece of software located below some 
        package <code><b>component.package</b></code>. It is mainly 
        represented via a single interface <code><b>ComponentInterface</b></code>
        that is locaed below the package <code><b>component.package</b>.api</code>.
        All
        checked exceptions 
      </subsection>
      <subsection name="Component-Package">
      </subsection>
    </section>
    <section name="Utility-Classes">
      <p>
      </p>
    </section>
    <section name="Resources">
      Java makes resource handling very easy. The tradeoff is that there are many 
      common mistakes developers do because they stop thinking about resource 
      management.
      <subsection name="Streams">
        If you deal with streams (InputStream, OutputStream, or related stuff) 
        please be very careful to ensure they are closed properly.
        Whenever an API method takes a stream as parameter, the javadoc must 
        specifiy wheter the stream is closed or not. If you want to close
        a stream make proper use of finally statements.
        The following example does NOT always close streams properly:
        <source>
FileInputStream sourceStream = new FileInputStream(source);
FileOutputStream destinationStream = new FileOutputStream(destination);
FileChannel sourceChannel = sourceStream.getChannel();
try {
  sourceChannel.transferTo(0, sourceChannel.size(), destinationStream.getChannel());
} finally {
  destinationStream.close();
  sourceStream.close();
}
        </source>
        A correct version looks as following:
        <source>
FileInputStream sourceStream = new FileInputStream(source);
try {
  FileOutputStream destinationStream = new FileOutputStream(destination);
  try {
    FileChannel sourceChannel = sourceStream.getChannel();
    sourceChannel.transferTo(0, sourceChannel.size(), destinationStream.getChannel());
  } finally {
    destinationStream.close();
  }
} finally {
  sourceStream.close();
}
        </source>        
      </subsection>      
      <subsection name="Dereference">
        The garbarge-collector is a fine thing, but anyways it does NOT prevent
        you from creating memory-holes in your software. Therefore you should
        carefully derefence objects that are no longer needed. This especially
        applies to objects stored in collections. If you use a map to cache
        objects you need to ensure that the cache size can only grow to a 
        defined maximum and objects can still be dereferenced using weak- or
        soft-references.
      </subsection>  
      <subsection name="Classpath-Resources">
        If you want to load a resource from the classpath do NOT use
        the following code-style:
        <source>
InputStream resourceStream = MyClass.class.getResourceAsStream("my-resource.xml");
        </source>
        This will NOT work properly in every environment such as
        some application-servers or frameworks that deal with special 
        class-loaders. Instead use <code>net.sf.mmm.util.resource.ClasspathResource</code>
        as following:
        <source>
DataResource resource = new ClasspathResource(MyClass.class, "my-resource.xml", false);
InputStream resourceStream = resource.openStream();
        </source>
      </subsection>
    </section>    
    <section name="Concurrency">
      In non-functional programming languages it is NOT always easy to deal with 
      cuncurrent access to shared objects. Please avoid <code>static</code> without
      <code>final</code>. If you design a class always consider if it is possible
      to do something in a thread-safe way. On the other hand never assume that 
      some implementation is thread-safe if NOT explicitly specified in the javadoc.
    </section>
    <section name="Tests">
      <p>For each sub-project module-tests should verify the integrity of the code.
      Therefore JUnit and its extensions (e.g. XmlUnit) are used. Maven (surefire) 
      is used to verify the unit-tests during the build process. The test-results
      and test-coverage are generated as report per sub-project on the web-site.
      It is hard to reach a high coverage but this is a goal of the project
      to increase the coverage continously.</p>
    </section>
  </body>
</document>
